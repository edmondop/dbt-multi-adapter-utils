from datetime import datetime
from pathlib import Path

import sqlglot
from sqlglot import exp

from dbt_multi_adapter_utils.config import Config
from dbt_multi_adapter_utils.sqlglot_adapter import normalize_dialect


def _replace_function_args_with_placeholder(node: exp.Func, *, placeholder: str) -> None:
    node.set("this", exp.to_identifier(placeholder))
    node.args.pop("expression", None)
    node.args.pop("expressions", None)
    node.args.pop("distinct", None)


def _extract_function_from_ast(ast: exp.Expression) -> exp.Func | None:
    for node in ast.walk():
        if isinstance(node, exp.Func):
            return node
    return None


def _create_dispatcher_macro(*, func_name: str, param: str) -> list[str]:
    func_lower = func_name.lower()
    public_macro = f"portable_{func_lower}"
    return [
        f"{{% macro {public_macro}({param}) -%}}",
        f"    {{{{ return(adapter.dispatch('{func_lower}', 'portable')({param})) }}}}",
        "{%- endmacro %}",
        "",
    ]


def _transpile_function_to_dialect(
    *,
    func_name: str,
    placeholder: str,
    primary_dialect: str,
    target_dialect: str,
) -> str:
    test_sql = f"SELECT {func_name}({placeholder})"
    ast = sqlglot.parse_one(test_sql, dialect=primary_dialect)

    func_node = _extract_function_from_ast(ast)
    if not func_node:
        raise ValueError(f"No function found in {test_sql}")

    _replace_function_args_with_placeholder(func_node, placeholder=placeholder)
    return func_node.sql(dialect=target_dialect)


def _generate_adapter_macro_lines(
    *,
    func_name: str,
    adapter: str,
    param: str,
    primary_dialect: str,
    placeholder: str,
) -> list[str]:
    func_lower = func_name.lower()
    normalized = normalize_dialect(adapter)

    try:
        func_sql = _transpile_function_to_dialect(
            func_name=func_name,
            placeholder=placeholder,
            primary_dialect=primary_dialect,
            target_dialect=normalized,
        )
        func_call = func_sql.replace(placeholder, f"{{{{ {param} }}}}")
    except Exception:
        func_call = f"{func_name}({{{{ {param} }}}})"

    return [
        f"{{% macro {normalized}__{func_lower}({param}) -%}}",
        f"    {func_call}",
        "{%- endmacro %}",
        "",
    ]


def _generate_macro_for_function(
    *,
    func_name: str,
    adapters: list[str],
    primary_dialect: str,
) -> str:
    param = "expression"
    placeholder = "__PLACEHOLDER__"

    macro_lines = _create_dispatcher_macro(func_name=func_name, param=param)

    for adapter in adapters:
        adapter_lines = _generate_adapter_macro_lines(
            func_name=func_name,
            adapter=adapter,
            param=param,
            primary_dialect=primary_dialect,
            placeholder=placeholder,
        )
        macro_lines.extend(adapter_lines)

    return "\n".join(macro_lines)


def generate_macros(config: Config, functions: list[str]) -> Path:
    if not functions:
        return config.macro_output

    config.macro_output.parent.mkdir(parents=True, exist_ok=True)

    primary_dialect = config.adapters[0]

    header = f"""{{#
  Auto-generated by dbt-multi-adapter-utils
  Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
  DO NOT EDIT MANUALLY

  Regenerate with: dbt-multi-adapter-utils generate
#}}

"""

    macro_content = header

    for func_name in sorted(functions):
        macro = _generate_macro_for_function(
            func_name=func_name,
            adapters=config.adapters,
            primary_dialect=primary_dialect,
        )
        macro_content += macro + "\n"

    config.macro_output.write_text(macro_content)

    return config.macro_output
